[["repaso---dplyr-y-ggplot.html", "2 Repaso - dplyr y ggplot 2.1 Bienvenidxs! 2.2 Medidas resumen y exploratorias 2.3 dplyr 2.4 ggplot", " 2 Repaso - dplyr y ggplot 2.1 Bienvenidxs! Antes que nada, felicitaciones por llegar hasta este momento! Hoja de ruta para estos días: Introducción (y repaso): dplyr y tidyr ggplot. Características básicas Visualizando la demografía: Pirámides de población Mapas temáticos Diagramas de Lexis: líneas de vida y superficies Curvas Kaplan-Meier Funciones I - Divide y reinaRás Modelos de crecimiento poblacional Estandarización Otras técnicas básicas Fuentes de datos accesibles desde R Funciones II - NaceR, MigraR, MoriR y otros eventos Tablas de mortalidad Indicadores de fecundidad Indicadores de migración Paquetes disponibles para el análisis demográfico Reportes dinámicos Documentación y contenido reproducible R Markdown/Quarto: reportes y presentaciones reproducibles 2.2 Medidas resumen y exploratorias Vamos a hacer un breve repaso de las funciones que más usamos (hasta ahora) , y para eso usamos nuestra ya conocida base de la EDER. ¿Qué hace cada una de estas funciones? eder_personas_br &lt;- read.csv(&quot;data/eder2019_personas.csv&quot;) dim(eder_personas_br) class(eder_personas_br) str(eder_personas_br) summary(eder_personas_br) colnames(eder_personas_br) ncol(eder_personas_br) nrow(eder_personas_br) Ahora vamos con una variable numérica como edad eder_personas_br$p3b, ¿qué hacen estas funciones? mean(eder_personas_br$p3b) min(eder_personas_br$p3b) max(eder_personas_br$p3b) range(eder_personas_br$p3b) 2.3 dplyr Empapémonos en cómo trabajar nuestras bases de datos 2.3.1 %&gt;%, seleccionar (select), renombrar (rename) ¿Se acuerdan del pipe (%&gt;% o |&gt;)? Este operador concatena operaciones sobre el mismo objeto, verbalizando el proceso, generando fluidez en nuestro razonamiento y mejor entendimiento para un tercero. En vez de f(x) (aplicar una función f() a un objeto x) se tiene x %&gt;% f() (tengo un objeto x y le aplico la función f()). Vamos a utilizarlo con las ya conocidas select() y `rename`` eder_personas &lt;- eder_personas_br %&gt;% select(id, nhogar, p2, p3b, p4) %&gt;% # toma el objeto *** y selecciona las columnas *** rename(id_viv = id, nhog=nhogar, sexo=p2, edad=p3b, rel_par=p4) # NuevoNombre = ViejoNombre 2.3.2 resumir (summarise) por grupos (group_by) Como nos interesa calcular medidas resumen para poder obtener conclusiones, plantear hipótesis o simplemente conocer más el fenómeno relevado/registrado en los datos, podemos usar summarise (resumen) y n() (contar filas) para contar, por ejemplo, cuántos casos hay en nuestra base: n_personas &lt;- eder_personas_br %&gt;% summarise(casos = n()) Esto crea un objeto n_personas con la cantidad de casos. Si queremos considerar el total de personas expandido (con su ponderador), tenemos que utilizar la función sum(factor expansión): n_personas_exp &lt;- eder_personas_br %&gt;% summarise(casos = sum(fexp)) Otro ejemplo: para contar cuántas viviendas fueron relevadas en la base debemos considerar casos con valor distinto en la variable de código de vivienda id: n_viviendas &lt;- eder_personas_br %&gt;% summarise(casos = n_distinct(id)) ¿Cuál es el promedio de personas por vivienda dentro de la encuesta? Con summarise() podemos aplicar cualquier función resumen sobre los datos. Por ejemplo: ¿Cuál es la edad promedio de las personas? ¿Cual es la edad mínima reportada? eder_personas_br %&gt;% summarise(edad_media = mean(p3b)) eder_personas_br %&gt;% summarise(edad_min = min(p3b)) eder_personas_br %&gt;% summarise(edad_max = max(p3b)) Y recuerden que podemos incluir todo lo anterior en una sola sentencia gracias al pipe %&gt;% eder_resumen&lt;- eder_personas_br %&gt;% summarise(n_personas = n(), n_viviendas = n_distinct(id), pers_x_viv = n_personas/n_viviendas, edad_media = mean(p3b), edad_min = min(p3b) ) Las operaciones principales que podemos realizar mediante summarise() las podés ver acá. Pero su utilidad se potencia cuando queremos segmentar por grupos. Esta agrupación antecede a summarise(), y requiere ser indicada con group_by() incluyendo como argumento las variables para agrupar. Por ejemplo, para conocer la cantidad de personas relevadas por sexo: pers_sexo &lt;- eder_personas_br %&gt;% group_by(p2) %&gt;% summarise(n_personas = n()) Seguro estas cantidades difieren según código de relación de parentesco con lx jefx de hogar. Pero primero podemos agregar la variable que describe los códigos. Carguemos como objeto el diccionario e incorporémoslo: cod_rel_par &lt;- data.frame(p4 = 1:14, p4_descripc = c(&quot;Jefe/a&quot;, &quot;Cónyuge/pareja&quot;, &quot;Hijo/a&quot;, &quot;Hijastro/a&quot;, &quot;Yerno o nuera&quot;, &quot;Nieto/a&quot;, &quot;Padre/madre/suegro/a&quot;, &quot;Hermano/a&quot;, &quot;Cuñado/a&quot;, &quot;Sobrino/a&quot;, &quot;Abuelo/a&quot;, &quot;Otro familiar&quot;, NA, # Recuerden que el valor 13 era vacío &quot;Otro no familiar&quot;)) eder_personas &lt;- eder_personas_br %&gt;% left_join(cod_rel_par, by = &quot;p4&quot;) eder_personas %&gt;% count(p4, p4_descripc) Joins!!! dplyr tiene las funciones típicas de join para el pareo de data.frames dependiendo la relación que deseemos. Ver más aquí. Y ahora podemos obtener la edad promedio de las personas encuestadas según relación de parentesco: edad_relpar &lt;- eder_personas %&gt;% group_by(p4_descripc) %&gt;% summarise(edad_media = mean(p3b)) 2.3.3 transformar (mutate), filtrar (filter), ordenar (arrange) Mediante mutate() podemos crear variables nuevas o reemplazar las existentes (si les ponemos el mismo nombre). Por ejemplo, hacemos una variable que nos diga si la persona es mayor de edad es_mayor, utilizando la función ifelse, la opción base de R. # creo una variable (sin resumir) eder_mayores &lt;- eder_personas %&gt;% mutate(es_mayor = ifelse(p3b &gt;= 18, 1, 0)) Podemos ordenar la tabla para ordenar de mayor a menor con arrange: eder_mayores &lt;- eder_mayores %&gt;% arrange(edad) eder_mayores # mejor al revés: descendente eder_mayores &lt;- eder_mayores %&gt;% arrange(desc(edad)) Recuerden que p3b = 9999 corresponde a No sabe o no responde. Entonces, nos conviene filtrarlos, utilizando filter(). Aunque primero chequeemos el rango de edades, ¿no? Y nos aseguramos de que el filtro se haya hecho bien table(eder_mayores$p3b) # La edad coherente más alta es 103 eder_mayores &lt;- eder_mayores %&gt;% filter(p3b &lt;= 103) # Operador lógico! ¿se acuerdan? range(eder_mayores$p3b) Vamos a unir todo lo que vimos hasta ahora: quiero obtener edad promedio de las personas que hicieron la encuesta retrospectiva por máximo nivel educativo alcanzado, pero solo si fueron lxs jefxs o cónyuges, por sexo. selec_jefcony_sex &lt;- eder_mayores %&gt;% filter(retro == 1, # Seleccionados para la encuesta retrospectiva p4 %in% 1:2, # p4 sea Jefx o cónyuge p3b &lt;= 103) %&gt;% # Edad conocida group_by(p2, # Sexo e_nivel) %&gt;% # Nivel educativo summarise(edad_media = mean(p3b)) |&gt; select(p2, e_nivel, edad_media) Si tuviéramos que relatar lo que estamos haciendo, sería algo del tipo: “tomá la eder, filtrame para traer solo jefxs y cónyuges, con edades conocidas que hayan contestado la retrospectiva, agrupámelos por estas variables y calculá el indicador para cada grupo; finalmente selecciona qué quieres mostrar”. Es una ¡composición de funciones!. Otra operación común es la de calcular distribuciones en una variable, segmentando con determinada agrupación. Podemos ver el porcentaje de mujeres que contestó el cuestionario retrospectivo por año de nacimiento. Considerar que cualquier operación resumen (media, suma, contar) en un data.frame agrupado resumirá por grupos. Aprovechemos eso: Porc_mujeres &lt;- eder_mayores |&gt; filter(retro == 1) |&gt; group_by(p3, p2) |&gt; summarise(N = n()) |&gt; mutate(porc = N/sum(N) *100) |&gt; filter(p2 == 2) |&gt; select(p3, porc) Pero esto no es tan útil. Entonces podemos hacer esa distribución por cohorte de nacimiento agrupada, recodificando el año de nacimiento con la función case_when en una nueva variable. unique(Porc_mujeres$p3) distr_coh &lt;- eder_mayores %&gt;% filter(retro == 1) |&gt; mutate(coh = case_when( p3 %in% 1948:1952 ~ &quot;1948-1952&quot;, p3 %in% 1968:1972 ~ &quot;1968-1972&quot;, TRUE ~ &quot;1978-1982&quot; )) %&gt;% group_by(coh, p2) |&gt; summarise(N = n()) |&gt; mutate(porc = N/sum(N) *100) |&gt; filter(p2 == 2) |&gt; select(coh, porc) 2.3.4 exportar ¿Y cómo exporto esto? Puede ser a csv o a Excel: getwd() # creo una carpeta de cosas exportadas dentro de data dir.create(&quot;data/export&quot;) write.csv(x = distr_coh, file = &quot;data/export/Distribución_cohortes.csv&quot;) # install.packages(&quot;openxlsx&quot;) library(openxlsx) write.xlsx(x = distr_coh, file = &quot;data/export/Distribución_cohortes.xlsx&quot;) 2.4 ggplot Todo gráfico esta compuesto, jearárquicamente, por: Datos: lo que contiene (en un formato determinado) aquello que queremos visualizar. Se utilza el argumento data. Capas Estética determinada: ¿quién es “x”?, ¿quién es “y”?, tamaño (size), color (color) y forma (shape), entre otros. Para esto se utiliza la función aes (de aestethics en ingles), y permite mapear las columnas de la data a cada argumento. Expresión geométrica de los datos. Las más comunes son: Puntos (geom_point) Líneas (geom_line) Barras (geom_bar) Transformación estadística (ajustar una regresión lineal, segmentar por percentiles, frecuencia de barra, etc.) Sistema de coordenas y Escalas: las medidas relativas con las cuales interpretar los datos y su transformación visual. Personalización de ejes y leyenda, cambiar a escala logarítmica, asignar una escala de colores, etc. Vamos a ver la distribución por edad de la EDER con ggplot. Para eso, primero vamos a calcular cuántas personas hay por edad. Recordemos que hay un código 9999 para valores desconocidos de edad. Aquí %&gt;% también funciona aunque recuerden que ggplot utiliza + en vez de %&gt;%. eder_dist &lt;- eder_personas %&gt;% filter(p3b &lt;= 103)|&gt; group_by(p3b) |&gt; summarise(n = n()) # genero un primer gráfico con los tres elementos básicos: eder_dist |&gt; # data ggplot(aes(x = p3b, y = n)) + # estética geom_line() # geometría Podemos separar mujeres y varones, distinguiéndolas por color y forma (en aes()). Y vamos a sacar a la gente sin información de sexo. eder_dist_s &lt;- eder_personas %&gt;% filter(p3b &lt;= 103, p2 %in% 1:2)|&gt; group_by(p2, p3b) |&gt; # Agrupo también por sexo summarise(n = n()) # genero un primer gráfico con los tres elementos básicos: g_eder_sexo &lt;- eder_dist_s |&gt; ggplot(aes(x = p3b, y = n, color = factor(p2), shape = factor(p2))) + # estética geom_line() + geom_point() g_eder_sexo Lo que se encuentra dentro de ggplot() vale para todas las capas, excepto se “pise”. Por ejemplo, da el mismo plot las siguientes dos sentencias: data %&gt;% ggplot(aes(x= EDAD, y = MUJER) + geom_line() que… data %&gt;% ggplot() + geom_line(aes(x= EDAD, y = MUJER)) pero no que… data %&gt;% ggplot(aes(x= EDAD, y = MUJER) + geom_line(aes(y = VARON)) Agreguemos un título, un subtítulo, modifiquemos el tamaño del punto, la posición y título de la leyenda, y especifiquemos las marcas en el eje x: g_eder_sexo &lt;- g_eder_sexo + # partimos del objeto anterior labs(title = &quot;Población por edad y sexo. EDER 2019&quot;, subtitle = &quot;CABA&quot;, caption = &quot;Fuente: IDECBA&quot;, x = &quot;Edad&quot;, y = &quot;n&quot;) + theme(legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, legend.title = element_blank()) + scale_x_continuous(breaks = seq(0,100,10)) # ups! g_eder_sexo Podemos definir una paleta de colores, cambiar la temática de fondo por una más simple y suavizar las series con algún modelo. Adicionalmente mediante ggsave podemos guardar el objeto como imágen en la extensión que se desee. mi_paleta &lt;- c(&quot;#000000&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;) # sistema Hexadecimal de colores g_eder_sexo &lt;- g_eder_sexo + scale_colour_manual(values = mi_paleta) + theme_bw() + geom_smooth(method = &#39;loess&#39;, span=.5) # podés jugar con span (0,1) ggsave(filename = &quot;g_eder_sexo.pdf&quot;, plot = g_eder_sexo, dpi = 150) g_eder_sexo Lo que vamos a hacer ahora, y solo a fines de entender cómo se puede armar, es llegar a un data frame donde tengamos el sexo en las columnas, y el nivel educativo en las filas. Para esto utlizaremos las funciones pivot (antiguamaente llamadas gather y spread, por si lo ves en la web). eder_ned_sexo &lt;- eder_personas %&gt;% filter(p2 %in% 1:2, # Elimino los que no tienen asignado el sexo y el nivel educativo e_nivel != 9) |&gt; mutate(sexo = case_when(p2 == 1 ~ &quot;Varon&quot;, # Recodifico p2 == 2 ~ &quot;Mujer&quot;), e_nivel_desc = case_when(e_nivel == 0 ~ &quot;No corresponde/escuelas especiales&quot;, e_nivel == 1 ~ &quot;Inicial&quot;, e_nivel == 2 ~ &quot;Primario incompleto&quot;, e_nivel == 3 ~ &quot;Primario completo&quot;, e_nivel == 4 ~ &quot;Secundario incompleto&quot;, e_nivel == 5 ~ &quot;Secundario completo&quot;, e_nivel == 6 ~ &quot;Superior / Universitario incompleto&quot;, e_nivel == 7 ~ &quot;Superior / Universitario completo y mas&quot;, e_nivel == 8 ~ &quot;Sin instruccion&quot;)) |&gt; select(sexo, e_nivel_desc) |&gt; group_by(sexo, e_nivel_desc) |&gt; summarise(n = n()) |&gt; pivot_wider(names_from = sexo, values_from = n)%&gt;% mutate(e_nivel_desc = factor(e_nivel_desc, levels = c(&quot;No corresponde/escuelas especiales&quot;, &quot;Inicial&quot;, &quot;Primario incompleto&quot;, &quot;Primario completo&quot;, &quot;Secundario incompleto&quot;, &quot;Secundario completo&quot;, &quot;Superior / Universitario incompleto&quot;, &quot;Superior / Universitario completo y mas&quot;, &quot;Sin instruccion&quot;))) |&gt; arrange(e_nivel_desc) Vamos a trabajar con barras. Recordemos que la estética fill equivale al atributo color de líneas o puntos. Como regla general, fill es como “relleno” y color para líneas o bordes. dist_ned_muj &lt;- eder_ned_sexo |&gt; ggplot(aes(x = e_nivel_desc, y = Mujer, fill = e_nivel_desc))+ geom_col() dist_ned_muj Vamos a darlo vuelta (flip) para que se vea mejor. Podemos hacerle unos cambios adicionales de paso: incluir titulo, subtítulo y fuente, cambiar las etiquetas de ambos ejes, incluir un tema distinto y cambiar el color de las barras. dist_ned_muj &lt;- dist_ned_muj + coord_flip() + scale_y_continuous(labels = abs) + labs(y = &quot;n&quot;, x = &quot;Nivel educativo&quot;, title = &quot;Mujeres por nivel educativo&quot;, subtitle = &quot;EDER CABA&quot;, caption = &quot;Fuente: en base a IDECBA&quot;) + theme_bw() dist_ned_muj Probablemente querramos varones y mujeres. Volvamos a poner el sexo como una variable, esta vez con pivot_longer eder_ned_sexo_long &lt;- eder_ned_sexo |&gt; pivot_longer(cols = c(&quot;Mujer&quot;, &quot;Varon&quot;), names_to = &quot;Sexo&quot;,values_to =&quot;n&quot;) eder_ned_sexo_long "]]
